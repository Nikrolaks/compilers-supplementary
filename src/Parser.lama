-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun fromOp(op) {	
  [s(op), fun(l, t, r) {Binop(op, l, r)}]	
}

-- Primary expression
var primary = memo $ eta (decimal @ fun (x) {Const (stringInt (x))} |
                          lident  @ fun (x) {Var (x)} |
                          inbr (s ("("), exp, s (")"))),
    exp = memo $ eta expr({
        [Left, {fromOp("!!")}],
        [Left, {fromOp("&&")}],
        [Nona, {
          fromOp("=="),
          fromOp("<="),
          fromOp(">="),
          fromOp("!="),
          fromOp("<"),
          fromOp(">")
        }],
        [Left, {fromOp("+"), fromOp("-")}],
        [Left, {fromOp("*"), fromOp("/"), fromOp("%")}]
      }, primary);

var conds = memo $ eta syntax (
      kFi {Skip}
    | kElse st=stmt kFi {st}
    | kElif e=exp kThen stmt1=stmt stmt2=conds {If(e, stmt1, stmt2)}
), base = memo $ eta syntax (
      -kSkip {Skip}
    | x=lident s[":="] ex=exp {Assn(x, ex)}
    | kRead x=inbr[s("("), lident, s(")")] {Read(x)}
    | kWrite x=primary {Write(x)}
    | kWhile e=exp kDo st=stmt kOd {While(e, st)}
    | kDo st=stmt kWhile e=exp kOd {DoWhile(st, e)}
    | kFor stmt2=stmt s[","] e=exp s[","] stmt1=stmt kDo stmt0=stmt kOd {Seq(stmt2, While(e, Seq(stmt0, stmt1)))}
    | kIf e=exp kThen stmt1=stmt stmt2=conds {If(e, stmt1, stmt2)}
), stmt = memo $ eta syntax(
    u=base s[";"] v=stmt {Seq(u, v)}
  | base
);

-- Public top-level parser
public parse = stmt;
