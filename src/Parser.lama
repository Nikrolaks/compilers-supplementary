-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun fromOp(op) {	
  [s(op), fun(l, t, r) {Binop(op, l, r)}]	
}

-- Primary expression
var primary = memo $ eta (decimal @ fun (x) {Const (stringInt (x))} |
                          lident  @ fun (x) {Var (x)} |
                          inbr (s ("("), exp, s (")"))),
    exp = memo $ eta expr({
        [Left, {fromOp("!!")}],
        [Left, {fromOp("&&")}],
        [Nona, {
          fromOp("=="),
          fromOp("<="),
          fromOp(">="),
          fromOp("!="),
          fromOp("<"),
          fromOp(">")
        }],
        [Left, {fromOp("+"), fromOp("-")}],
        [Left, {fromOp("*"), fromOp("/"), fromOp("%")}]
      }, primary);

var base = memo $ eta syntax (
      -kSkip {Skip}
    | x=lident s[":="] ex=exp {Assn(x, ex)}
    | kRead x=inbr[s("("), lident, s(")")] {Read(x)}
    | kWrite x=primary {Write(x)}
), stmt = memo $ eta syntax(
    u=base s[";"] v=stmt {Seq(u, v)}
  | base
);

-- Public top-level parser
public parse = stmt;